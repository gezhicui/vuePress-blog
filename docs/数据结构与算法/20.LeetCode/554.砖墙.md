---
title: LeetCode 554 砖墙(哈希表)
date: 2022-06-07 11:33:53
permalink: /pages/d4c030/
categories:
  - 数据结构与算法
tags:
  - Leetcode
  - 哈希表
author:
  name: 杨雨翔
  link: https://github.com/gezhicui
---

LeetCode 刷题也有一段时间了，目前在 120 题左右，刷题过程中经常遇到一些醍醐灌顶的解法，特开一个分类来记录下一些值得分享的解法

本题的实现基于哈希表，题目如下：

::: tip 题目
你的面前有一堵矩形的、由 `n` 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。

你现在要画一条**自顶向下**的、穿过**最少**砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。**你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。**

给你一个二维数组 `wall` ，该数组包含这堵墙的相关信息。其中，`wall[i]` 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 **穿过的砖块数量最少** ，并且返回 **穿过的砖块数量** 。

:::
![](https://yangblogimg.oss-cn-hangzhou.aliyuncs.com/blogImg/20220607124156.png)

```
示例 1：
输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出：2
```

```
示例 2：
输入：wall = [[1],[1],[1]]
输出：3
```

<!-- more -->

本题可以用哈希表来解，由于砖墙是一面矩形，所以对于任意一条垂线，其**穿过的砖块数量加上从边缘经过的砖块数量之和是一个定值**，即砖墙的高度。

因此，问题可以转换成求「**垂线穿过的砖块边缘数量的最大值**」，用砖墙的高度减去该最大值即为答案。

虽然垂线在每行至多只能通过一个砖块边缘，但是每行的砖块边缘也各不相同，因此我们需要用**哈希表统计所有符合要求的砖块边缘的数量**。

注意到题目要求垂线不能通过砖墙的两个垂直边缘，所以砖墙两侧的边缘不应当被统计。因此，我们只需要统计每行砖块中除了最右侧的砖块以外的其他砖块的右边缘即可。

具体地，我们有以下步骤：

- 我们遍历砖墙的每一行，对于当前行，我们从左到右地扫描每一块砖，使用一个累加器记录当前砖的右侧边缘到砖墙的左边缘的距离
- 将除了最右侧的砖块以外的其他砖块的右边缘到砖墙的左边缘的距离加入到哈希表中。
- 最后我们遍历该哈希表，找到出现次数最多的砖块边缘，这就是垂线经过的砖块边缘，而该垂线经过的砖块数量即为砖墙的高度减去该垂线经过的砖块边缘的数量。

具体代码如下

```js
var leastBricks = function (wall) {
  //创建一个map用来存放每个距离左侧数值相同的砖块数量
  const cnt = new Map();
  for (const widths of wall) {
    const n = widths.length;
    let sum = 0;
    //遍历该行的所有砖，把每个砖块距离左侧的数值加入到哈希表中
    for (let i = 0; i < n - 1; i++) {
      sum += widths[i];
      //如果有其他砖块距离左侧的长度和当前砖块距离左侧长度相等，则++,否则=1
      cnt.set(sum, (cnt.get(sum) || 0) + 1);
    }
  }
  let maxCnt = 0;
  //遍历，取出最多的距离左侧长度相等的砖，高度-该值就是穿过最少的砖
  for (const [_, c] of cnt.entries()) {
    maxCnt = Math.max(maxCnt, c);
  }
  return wall.length - maxCnt;
};
```

一开始想半天 没想到能用哈希表来解，看了官方示例之后真是连连称奇。特地开个文章记录下
